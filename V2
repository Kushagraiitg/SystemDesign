Caching at different levels
- Very usecase specific
- Where you are caching?
	- API server main memory
		- size limitation in RAM
		- not persistent
		- different instances may not all have the same values
			- inconsistency
		- local to one host and need not all servers
		- Network calls not made, performance boosts
		- helpful for sticky sessions
			- can be result of load balancing, or use the LB for this
		- helpful for very static data
		- TTL is crucial, size limit for cache is important
	- Redis like instances
		- single source of truth
		- 
	- DB views(materialized)
		- highly consistent
		- mostly for relational DBs
		- add/derive columns in new table/view
		- helpful as it avoids joins
		- triggers for updates
	- Browsers(local storage)
		- usecase: personalized recommendations for each user
		- TTL can be optimized
	- CDN servers
		- proxy b/w user and server, and ctrl'ed by TTL
		- Images/videos
		- can Cache responses as well that can be nearly static
		- can go directly CDN->USER in USER->CDN->SERVER->DB->SERVER->CDN->USER
	- Disk level caching in the server
		- in addition to OS and everything in EC2 you can also use disk
		- Not memory bound(8GB RAM vs 20GB Disk)
		- Helps save the network I/O, local disk read is faster
	- Caching on LB
	- API Gateway
- Redis: It can serve as a cache/ No-SQL DB/msg queue
	- In memory data store
	- supports multiples DS
	- RDB snappshots/AOF for durability
	- Clustering for multiple hosts
	- master slave replication for redundancy and LB
	- high availability by redis sentinel
	- pub/sub msging
	- monitoring and management
	- Commonly used for caching, session management, real-time analytics, leaderboard systems, and pub/sub messaging. Its versatility makes it suitable for a wide range of applications.
Scaling
- Ability to handle large number of concurrent requests
	- concurrent requests
- Vertical Scaling
	- Easy to manage
	- Risk of downtime
	- Hulk
		-infra made bulky, add more CPU, RAM, DISK
	- HW limitations of two HW components to connect
		- NW cards have buses to transfer data and need to be compatible
- Horizontal Scaling
	- Linear amplification
	- Fault tolerance
	- Network partitioning
	- Not infinite scaling
		- dependency resources like DBs or other services can be impacted

- Good scaling plan
	- first vertical
	- then always horizontal
	- knowing expected traffic first
		- ASGs take their own time to scale for high load
	- LOAD testing is ALWAYS needed
	- Premature optimization does not help
	- Always scale bottom up(Scale the ones you are dependent on first)
	- And scale down from top down
	- Otherwise Cascading failures happen
	
- Scaling DB
	- Vertical Scaling
	- Horizontal Scaling
		- Read Replicas
			- read to write-> 99:1
			- readers more than writers
			- master, replica and async replication b/w db's
				- write to master is sent to master
					- actually replica pulls the updates from master in async
				- read to replica and write to master
				- 
				

Concurrency

Delegation

Communication
